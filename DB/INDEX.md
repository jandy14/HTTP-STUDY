# Index
인덱스는 자료를 빠르게 찾기위한 데이터이다.

테이블에서 열에 관한 인덱스를 생성할 수 있다.

인덱스를 생성하게 되면, 자료를 찾을 때(select where) 모든 자료를 확인하는 것(full scan)이 아닌 정렬된 인덱스를 통해 자료를 찾아 기존보다 빠르게 찾을 수 있다.

# 인덱스의 원리
특정 컬럼에 대해 인덱스를 생성하게 되면 인덱싱을 위한 테이블이 생성된다.

인덱스 테이블은 해당 컬럼값을 기준으로 정렬해둔 데이터이고, B Tree구조가 많이 사용된다.

인덱싱을 해둔 컬럼값을 where로 찾게 되면 인덱스 테이블을 통해 빠르게(full scan-O(n), indexing-O(logN)) 해당 행을 찾을 수 있다.

방식에 따라 실제 물리적인 데이터의 구조를 정렬하는 방식(Clustered Index)와 별도의 테이블을 생성해 데이터의 위치를 저장해두는 방식(Non-Clustered Index)가 존재한다.

## 왜 B-Tree 일까
B Tree(정확히는 B+ Tree)는 트리가 균형잡힌 모양을 지속적으로 유지할 수 있게 만든 자료구조이다.

데이터가 정렬되어 있고, 트리의 구조이기 때문에 O(logN)으로 데이터를 찾을 수 있다. 또 데이터의 삽입/삭제에도 O(logN)의 시간이 소요된다.

배열로 구현된 바이너리 서치도 탐색에 O(logN)이지만 데이터 삽입/삭제에는 O(n)이 필요하다.

리스트는 삽입/삭제에 O(1)이지만 바이너리 서치가 불가능하다.

그렇다면 바이너리 서치가 가능하게 중간 노드들의 주소를 저장해 두는건 어떨까

당장은 성능이 나오지만 삽입/삭제가 일어날 수록 중간 노드가 변하게 되며, 이를 지속적으로 관리해준다면 그게 B tree다.

## Clustered Index
클러스터드 인덱스는 키를 기준으로 데이터의 물리적인 위치가 정렬된다. 따라서 테이블 당 1개의 클러스터드 인덱스를 가질 수 있다.

키가 변경되면 데이터를 전부 다시 정렬해야하므로 설정하기 전에 신중히 해야한다.

키는 다음과 같이 정한다.
1. 기본키
2. 대체키
3. 위가 전부 없을 경우 6바이트 크기의 히든키(rowid)를 생성

그에 비해 Non-Clustered Index는 데이터의 위치를 저장하기 때문에 실제 데이터의 위치는 변경되지 않고, 여러 개를 생성할 수 있다.

## 커버링 인덱스
인덱스를 통해서 질의에 필요한 데이터를 모두 얻을 수 있으면 `커버링 인덱스`라고 한다. 인덱싱된 값만으로 SELECT됐을 때 발생한다.

해당 질의가 자주 사용된다면 인덱스가 디비 버퍼에 캐시되어 있었을 가능성이 높다는 점에서 디스크 I/O를 줄이는데 큰 역할을 한다.

# 인덱스의 장단점

인덱스를 사용하게 되면 빠르게 자료를 찾을 수 있지만 그에 따른 비용이 존재한다. 하나씩 살펴보자.

인덱스의 장점
- where문 검색 속도 증가

인덱스의 단점
- 추가적인 데이터
- 생성시 시간이 많이 걸릴 수 있음
- 데이터 변경,추가,삭제시 인덱스 테이블도 변경되므로 시간 증가
- 잘못된 인덱스 사용은 성능에 악영향만 줌

# 결론
인덱스는 자주 접근하고, 데이터의 중복이 적은 컬럼으로 정하는 것이 좋다.

# 참고 자료
인덱스<br>
https://brunch.co.kr/@skeks463/25

https://lalwr.blogspot.com/2016/02/db-index.html

https://itholic.github.io/database-index/

인덱스 효과적으로 사용하기
https://yurimkoo.github.io/db/2020/03/14/db-index.html

Clustered/Non-Clustered
https://s1107.tistory.com/38

커버링 인덱스
https://icarus8050.tistory.com/44

커버링 인덱스
https://d2.naver.com/helloworld/1155
