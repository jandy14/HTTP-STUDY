# 특징
자바스크립트로 작업을 하기위해 알아둬야 할 점들을 알아보자. (ES6를 기준으로 설명한다.)

# 변수 선언
ES6 이전에는 변수 선언을 위해 var라는 키워드를 사용했다.

var는 Hoisting(호이스팅)이라는 현상(?)이 일어난다.(자세한건 뒤에)

ES6에서는 let과 const라는 키워드를 추가했다. 호이스팅이 일어나지 않으며, 중복으로 선언하면 에러를 발생시킨다.

- let은 호이스팅이 일어나지 않는 변수
- const는 호이스팅이 일어나지 않는 상수

## Hoisting
var로 선언된 변수는 호이스팅이 일어난다.

호이스팅은 선언부를 모두 유효범위 최상단으로 끌어올리는 것을 말한다.

유효범위에 대해 얘기하려면 Scope에 대해 얘기해야하지만 일반적인 언어와 동일하므로 생략한다. (블록, 함수, 전역)

호이스팅으로 선언부가 옮겨질 때는 함수와 전역으로만 유효범위가 정해진다. (블록은 무시!)

예시를 보자.
```javascript
console.log(foo);
var foo = 123;
console.log(bar);
let bar = 234;
```
위 예시는 아래로 변경되어 실행된다.
```javascript
var foo;
console.log(foo); // undefined
foo = 123;
console.log(bar); // error!!
let bar = 234;
```
중요한 점은 선언만 옮겨지고 할당은 제자리에서 한다는 점이다.

함수도 호이스팅 대상인데 함수를 선언하는지 표현식으로 나타냈는지에 따라 동작이 다르다.
```javascript
foo();
bar();
function foo() {
    console.log("foofoo");
}
var bar = function () {
    console.log("barbar");
}
```
위 예시는 아래로 변경되어 실행된다.
```javascript
var bar;
function foo() {
    console.log("foofoo");
}
foo();
bar(); // error!!
bar = function () {
    console.log("barbar");
}
```

호이스팅은 알아는 둬야할 점이지만 응용하지는 말아야한다.

변수 선언은 let을 이용해서 하기로 하자.

# 원시 타입
자바스크립트는 모든 것이 Object라고 생각하지만 실제로는 원시 타입이 존재한다.

- Booleans
- null (의도적으로 할당한 빈 객체값)
- undefined (아무값도 할당하지 않음)
- number (64bit float, 정수형은 없다)
- string
- symbol

하지만 메소드를 사용하기위해 Boolean, Number, String, Symbol와 같은 Wrapper Object가 존재한다.

# Falsy & Truthy
다음 값들은 논리 연산에서 False로 취급되며, Falsy값이라고 한다.
- undefined
- null
- 0, -0
- ''
- NaN (Not A Number : 수 연산에 null값이 들어가거나 할 때의 결과값)

그 외의 값들은 논리 연산에서 true로 취급되고, Truthy값이라고 한다.
```
파이썬에선 empty list가 false로 취급되지만 JS에서는 true로 취급된다는 점에 유의!
```

# First Class Citizen(일급 시민, 일급 객체)
일급 시민은 다음과 같은 특징을 가진다.
- 변수에 할당 가능
- 인자로 사용 가능
- 반환값으로 사용 가능

JS는 함수를 객체로 취급하기 때문에 함수도 일급 객체다.

그래서 함수를 인자로 받거나 리턴하는 `고차 함수`가 존재한다.

map, filter, reduce같이 내장된 고차 함수가 있는데, 필자는 파이썬을 하면서 써봤으니 자세한건 알아서 찾아보자!

# 객체
자바스크립트의 객체는 Object의 구현체이며, 파이썬의 딕셔너리같은 데이터다. (해시맵,해시테이블)

# 클로저
다음 예제를 보자.
```javascript
function makeAdder(a) {
  // 내부 함수
  return function(b) {
    return a + b;
  };
}
var add5 = makeAdder(5);
var add20 = makeAdder(20);
add5(6); // 11
add20(7); // 27
```

JS는 함수가 호출되면 `범위 객체`가 생성된다.

보통 범위 객체는 함수가 리턴된 후 참조되지 않기 때문에 가비지 콜렉터에 의해 정리되지만 함수의 내부 함수가 범위 객체를 참조하고 내부 함수가 리턴되면서 참조되고 있으므로 범위 객체가 남아있게 된다.

`클로저`는 `함수와 함수에 의해 생성되는 범위 객체`를 지칭하는 용어다.

또 하나의 특징은 위 예제의 a는 직접적으로 접근할 방법이 없다.(private)

클로저를 통해 상태를 저장할 수 있다.(클래스처럼?)

# Rest, Spread
spread는 객체가 가진 값을 각각의 값으로 풀어내는 연산자다.
```javascript
const numbers = [1, 2, 3, 4, 5];

const spreadNumbers = [...numbers, 1000, ...numbers];
console.log(spreadNumbers); // [1, 2, 3, 4, 5, 1000, 1, 2, 3, 4, 5]
```
rest는 각각의 값을 다시 묶어주는 연산자다.
```javascript
function sum(...rest) { //이름이 rest일 필요는 없다.
  return rest.reduce((acc, current) => acc + current, 0);
}

const result = sum(1, 2, 3, 4, 5, 6);
console.log(result); // 21
```

# 비구조화
예제로 알아보자
```javascript
const object = { a: 1, b: 2 };
const { a, b } = object;

console.log(a); // 1
console.log(b); // 2
```
특징이라면 자바스크립트답게? 값이 없어도 없는대로 실행된다는 점이다. (파이썬과의 차이점)
```javascript
const object = { a: 1 };
const { a, b } = object;

console.log(a); // 1
console.log(b); // undefined
```
기본값을 주는 것이 가능하다.
```javascript
const object = { a: 1 };
const { a=100, b=100 } = object;

console.log(a); // 1
console.log(b); // 100
```
rest와 같이 사용 가능하다.
```javascript
const object = { a: 1, b: 2, c: 3, d: 4 };
const { c, ...anothers } = object;

console.log(c); // 3
console.log(anothers); // { a: 1, b: 2, d: 4 }
```

rest는 array와도 같이 사용가능하다. 사용법은 비슷하니 직접 알아보자!

# this
다른 언어의 this와는 다른 좀 복잡하게 사용된다.

최대한 간단히 설명한다. (필자도 불명확한 부분이 있다.)

this는 함수를 실행한 주체가 누구냐에 따라 달라진다.

함수는 다음 4가지 방식으로 실행된다.
- 함수 실행: alert('Hello World!')
- 메소드 실행: console.log('Hello World!')
- 생성자 실행: new RegExp('\d')
- 간접 실행: alert.call(undefined, 'Hello World!')

일반적인 함수 실행은 실행 주체가 없다. 그래서 this는 전역 객체를 가리키게 된다.(엄격 모드에서는 undefined)

메소드 실행에서는 해당 메소드를 가진 객체가 실행 주체가 된다.

생성자로써의 함수 실행은 새롭게 만들어지는 객체가 this가 된다.

간접 실행은 첫 인자로 this가 될 객체를 받는다. 그러니 실행 주체는 인자 객체가 된다.

주의해야 할 상황이 있다.
```javascript
var numbers = {  
   numberA: 5,
   numberB: 10,
   sum: function() {
     console.log(this === numbers); // => true
     function calculate() {
       // this는 window, 엄격 모드였으면 undefined
       console.log(this === numbers); // => false
       return this.numberA + this.numberB;
     }
     return calculate();
   }
};
numbers.sum(); // NaN, 엄격 모드였으면 TypeError
```
sum함수 내부에서의 calculate함수는 일반적인 함수 호출이라 this는 numbers가 아닌 전역 객체가 된다.(엄격 모드면 undefined)

this를 고정하기 위한 bind라는 함수가 존재한다.

bind함수를 통해서 this를 지정하게 되면 간접 실행을 위한 call,apply를 사용해도 this가 변하지 않게 되며, bind를 다시 해준다해도 this는 변하지 않는다. new를 통해 새로운 객체를 만들면 this를 변경할 수 있지만 권장되는 사용은 아니다.

----
ES6부터 class와 화살표 함수가 추가 되었는데, class는 일반적인 this의 규칙을 따르지만 화살표 함수에 사용되는 this는 또다른 규칙을 가진다.

화살표 함수는 선언되는 위치의 현재 문맥의 this를 bind한다.

# prototype
JS는 프로토타입 기반 객체 지향 언어라고 불린다.

JS에서는 함수를 선언하면 2가지 객체가 생성된다.
- 함수 객체
- 프로토타입 객체

함수 객체는 다음과 같은 속성을 기본적으로 가지고 있다.
- prototype (함수 선언시 생성된 프로토타입 객체의 참조)
- \_\_proto\_\_ (함수 객체가 상속?받은 프로토타입 객체의 참조)

프로토타입 객체는 다음과 같은 속성을 기본적으로 가지고 있다.
- constructor (함수 선언시 생성된 함수 객체의 참조)
- \_\_proto\_\_ (프로토타입 객체가 상속?받은 프로토타입 객체의 참조)

new를 통해 함수를 실행하면 함수는 생성자로써 실행되고 함수 객체가 참조하고 있는 prototype을 \_\_proto\_\_로 가지는 새로운 객체를 생성하게 된다.

예시로 이해해보자.
```javascript
function Person (name, gender, sayHello) {
  this.name = name;
  this.gender = gender;
  this.sayHello = sayHello;
}
let foo = new Person("Lee", "male", function () {});
```
위 코드는 아래와 같은 객체관계를 가지게 된다.

![객체와 프로토 타입](https://media.vlpt.us/post-images/chadonghwa/2ec40bb0-de0a-11e9-9cc5-8ddfd9e943b1/image.png)

눈 여겨 볼 점이 몇가지 있다.
- Person함수가 function이라는 객체를 프로토타입으로 가지고 function은 Object를 프로토타입으로 가진다. (function도 Object를 물려받은 객체다.)
- foo는 다음과 같은 속성을 가진다.
  - name : "Lee"
  - gender : "male"
  - sayHello : function () {}
  - \_\_proto\_\_ : Person의 프로토타입 객체 == Person.prototype
    - constructor : Person 함수 객체
    - \_\_proto\_\_ : Object의 프로토타입 객체
      - constructor : Object의 함수 객체
      - 프로토타입에 정의된 여러 Object 프로토타입용 함수들
      - toString : 함수 객체 (Object 프로토타입용 함수 중 하나)
      - \_\_proto\_\_ : 없음!!

----
위 예제의 foo는 toString을 호출할 수 있다.
```javascript
foo.toString();
```
하지만 foo에는 toString이라는 값이 없다. JS에서는 프로토타입에서 toString 찾아보기 시작한다. foo.\_\_proto\_\_이자 Person.prototype인 객체를 찾아본다. 없다면 foo.\_\_proto\_\_.\_\_proto\_\_ (Person.prototype.\_\_proto\_\_ 이자 Object.prototype)에서 찾아본다. 다행히 Object.prototype에서 toString을 찾아 실행하게 된다. 하지만 Object.prototype에서도 찾지 못하면 에러를 띄운다.

이런 식으로 계속 값을 찾아 프로토타입을 올라가는 것을 `prototype chaining`이라고 한다.

몇가지 빠진 설명이 있다.
- 모든 함수는 생성자로써 사용될 수 있다. 그러니 생성자 함수라는 표현은 맞지 않다.
- Person.prototype.newfunc = function () {} 과 같이 프로토타입에 값을 추가할 수 있고 이는 모든 상속받은 객체가 참조할 수 있다. (메모리 절약)

# class

# Promise

# 참고 자료
- Hoisting
  - https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html
- 고차 함수
  - https://velog.io/@rememberme_jhk/JS-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98-higher-order-function
- JS 기초
  - https://learnjs.vlpt.us/
- JS 객체, 클로저
  - https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript#.ED.8F.90.ED.8F.AC_.28Closures.29
- this
  - https://github.com/FEDevelopers/tech.description/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-this%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85-1
  - https://github.com/FEDevelopers/tech.description/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-this%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85-2
- prototype
  - https://velog.io/@chadonghwa/proto-prototype-constructor-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-upk0wh7a1g
  - https://velog.io/@adam2/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Prototype-%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC